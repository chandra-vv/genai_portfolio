"""
multi_agent_assistant/graph/langgraph_multi_agent.py

LangGraph Wiring:
-----------------
This module composes the end-to-end multi-agent workflow:

1) planner_node:
   - Uses the planner agent to split a complex question into sub-questions.
   - Initializes the loop index and prepares state for retrieval.

2) retriever_node:
   - Uses the retriever agent to answer the current sub-question.
   - Appends {"question": ..., "answer": ...} to the state's answers list.
   - Increments the loop index.

3) check_all_answered (conditional edge):
   - Controls the loop: keeps calling `retriever_node` until all sub-questions are answered.

build_multi_agent_graph():
   - Creates and compiles the StateGraph using the above nodes and condition.
"""

from __future__ import annotations

import os
import sys
from typing import TypedDict, List, Dict

# Ensure package imports work when running from app.py
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from langgraph.graph import StateGraph, END
from multi_agent_assistant.agents.planner_agent import planner_agent
from multi_agent_assistant.agents.retriever_agent import retriever_agent


# ---------------------------------------------------------------------------
# State schema
# ---------------------------------------------------------------------------
class GraphState(TypedDict):
    """
    State carried through the graph.

    Fields:
        question: The original user query.
        sub_questions: List of sub-questions generated by the planner.
        answers: List of QA dicts; each item is {"question": str, "answer": str}.
        current_index: Loop index pointing to the next sub-question to answer.
    """
    question: str
    sub_questions: List[str]
    answers: List[Dict[str, str]]
    current_index: int


# ---------------------------------------------------------------------------
# Nodes
# ---------------------------------------------------------------------------
def planner_node(state: GraphState) -> GraphState:
    """
    Planner node:
    - Takes the user's main question (state['question'])
    - Produces a list of sub-questions via the planner agent
    - Resets/initializes loop bookkeeping

    Returns:
        Updated state (GraphState)
    """
    # Generate sub-questions (planner_agent returns List[str])
    sub_questions = planner_agent(state["question"])

    # Initialize/normalize loop state
    state["sub_questions"] = sub_questions or []      # ensure list
    state["current_index"] = 0                        # start from the first sub-q
    state.setdefault("answers", [])                   # ensure list exists

    return state


def retriever_node(state: GraphState) -> GraphState:
    """
    Retriever node:
    - Answers the current sub-question using the retriever agent
    - Appends {"question": ..., "answer": ...} to state['answers']
    - Advances the loop index

    Returns:
        Updated state (GraphState)
    """
    idx = state["current_index"]
    subs = state.get("sub_questions", [])

    # Nothing to do if there are no sub-questions or we've answered them all
    if not subs or idx >= len(subs):
        return state

    current_sub_q = subs[idx]

    # retriever_agent expects {"question": "..."} and returns a string answer
    answer_text = retriever_agent({"question": current_sub_q})

    # Ensure answers list exists and append the new QA pair
    state.setdefault("answers", [])
    state["answers"].append({
        "question": current_sub_q,
        "answer": answer_text
    })

    # Advance to the next sub-question
    state["current_index"] = idx + 1
    return state


# ---------------------------------------------------------------------------
# Loop condition
# ---------------------------------------------------------------------------
def check_all_answered(state: GraphState) -> bool:
    """
    Conditional edge function:
    - Returns True when all sub-questions have been answered (end the loop)
    - Returns False otherwise (continue looping retriever_node)

    Returns:
        bool
    """
    return state["current_index"] >= len(state.get("sub_questions", []))


# ---------------------------------------------------------------------------
# Graph builder
# ---------------------------------------------------------------------------
def build_multi_agent_graph():
    """
    Build and compile the LangGraph for the multi-agent flow.

    Graph shape:
        entry -> planner -> retriever -(until done)-> END

    Returns:
        Compiled graph object (call .invoke(initial_state_dict) to run)
    """
    workflow = StateGraph(GraphState)

    # Register nodes
    workflow.add_node("planner", planner_node)
    workflow.add_node("retriever", retriever_node)

    # Entry point goes to the planner first
    workflow.set_entry_point("planner")

    # Planner always flows to retriever
    workflow.add_edge("planner", "retriever")

    # Loop retriever until every sub-question is answered
    workflow.add_conditional_edges(
        "retriever",
        check_all_answered,
        {
            True: END,          # stop when done
            False: "retriever"  # otherwise, keep retrieving (next sub-q)
        },
    )

    # Note: newer LangGraph versions don't take input_schema here
    graph = workflow.compile()
    return graph
